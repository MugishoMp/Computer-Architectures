# The contents of the different pipeline registers and why it was necessary to put 
these fields in the pipeline register.

    IF_IDRegisters:
    The IF_IDRegisters pipeline register contains two important fields. The PC 
    (Program Counter) keeps track of the memory address of the next instruction to 
    be fetched. Which is important for determining the location of the next 
    instruction in memory. The INSTRUCTION_WORD field stores the actual instruction 
    fetched from memory. It provides a temporary place for the instruction 
    before it is passed to the subsequent stages for decoding and execution.

    ID_EXRegisters:
    In the ID_EXRegisters pipeline register, several fields are included to 
    facilitate the execution of instructions. The PC field represents the program 
    counter at the beginning of the current pipeline stage. RS1 and RS2 store the 
    values read from the register file for the source registers of the instruction. 
    These values are necessary for following stages to operate on the correct 
    register values. RD (Destination Register) represents the destination register 
    where the result of the operation will be stored.

    Additionally, A and B fields store the register numbers of the register that 
    we read from, and the IMMEDIATE field holds the sign-extended immediate value from 
    the instruction The CONTROL_SIGNALS field contains a control signals object 
    that sends of the various control signals steering all of the necessary
    components like the ALU or a mux.

    EX_MRegisters:
    The EX_MRegisters pipeline register includes important fields to manage the 
    execution of instructions. The PC field represents the program counter at the 
    beginning of the current pipeline stage. The CONTROL_SIGNALS field contains 
    control signals guiding the execution in the Execute stage. The ALU_OUTPUT field 
    stores the result of the ALU operation, while RS2 holds the value of the second 
    source register for the ALU operation.

    The RD (Destination Register) field represents the register number of the 
    destination register where the result will be stored. For branch instructions, 
    the BRANCH_PC field holds the target address, BRANCH_DECISION is a bool that 
    indicates whether to take the branch or continue sequentially, and 
    BRANCH_DELAY_SLOT flags whether the current instruction is in a branch delay slot.

    M_WBRegisters:
    Finally, the M_WBRegisters pipeline register encompasses fields crucial for the 
    Memory and Write Back stages. The PC field represents the program counter. 
    The CONTROL_SIGNALS field contains control signals guiding the execution in 
    the Memory stage. The DATA_READ_FROM_MEMORY field holds the data read from 
    memory, while ALU_RESULT stores the result of the ALU operation.

    The RD (Destination Register) field represents the register number of the 
    destination register where the result will be stored. 

# Which parts of your emulator do and do not work.
    My emulator works up until level 4. level 5 and beyond do not work, so there is 
    no pipelining.

# Your approach to testing: which micro programs have been written and why?:
    Prioritizing micro programs that handle basic and often used instructions is how
    I tested my OpenRisc 1000 emulator to make sure it is reliable and accurate. The 
    micro programs that were chosen offer a variety of features. The no-operation 
    (L_NOP) test confirms that the emulator can smoothly carry out simple commands. 
    Immediate value loading (L_MOVHI), which guarantees the proper loading of a 
    32-bit immediate's high portion into a register, is another crucial component.

    Furthermore, tests for linking and branching instructions (L_J and L_JAL) are 
    essential for evaluating how well the emulator can manage control flow 
    activities. Micro programs for load and store instructions (L_LWZ, L_LBZ, L_LBS, 
    L_SW, L_SB, and L_SH) are also included in the suite to verify the emulator's 
    ability to correctly load and store data in memory.

    To make sure that basic arithmetic, logical, and comparison operations are 
    carried out correctly, arithmetic instructions (L_ADD, L_SUB, L_AND, L_OR, 
    L_SLL, L_SRL) and comparison instructions (L_SFEQ, L_SFNE, L_SFGTU, L_SFGTS, 
    L_SFGES, L_SFLES) are checked.

    Additionally, the selection includes evaluating how the emulator handles 
    immediate arithmetic operations (L_ADDI, L_ANDI, and L_ORI) and jump 
    instructions to registers (L_JR). This all-encompassing method covers many 
    facets of control flow, memory access, arithmetic, and logic operations with \
    the goal of offering a strong basis for testing.

    I also learned that there could be an issue with the skeleton code that was 
    provided to us for this assignment from these unit tests. Because trying to 
    retrieve a single byte from the bus in the provided skeleton code returns 0, 
    even though we know that there is a value at that point, so lbs and lbz do not 
    function!

# Any particular choices you have made for your implementation.
    Some of the "pre-" bit shifting, which happen in l.movhi for example happen in 
    the ALU, occurred because, when I first started working on this project, I was 
    told that there was no need to do this in the decoder, but I subsequently found 
    out that this was untrue. And because I was already rather far along with the 
    emulator's implementation, I decided to perform this shifting in the ALU before 
    the actual ALU operation happened as an interim solution. Therefore, some of the
    commands, like Movhi, technically take more clock cycles then on paper.

    In the case of the pipeline itself, I concentrated primarily on carrying out the 
    instructions that I discovered in the dump.txt files for every test. All 1000 
    OpenRISC instructions can be printed by the instruction formatter, though.



# For level 4: describe how you have dealt with delay slots in the non-pipelined case.
    In order to cope with delay slots, I have set the PC's instruction memory 
    address either before or after we set the PC with the output of the mux that 
    determines whether we want to take the branch PC or the next PC. We take this 
    action prior to deciding on the next PC in the event of a branch delay slot. As 
    a result, in the event of a branch PC, we must successfully complete every 
    pipeline stage before returning with the branch PC already installed in the 
    instruction memory. In the execute stage, we determine whether or not there is a 
    branch delay slot and whether or not we need to jump after this instruction. 
    Which is synonymous with each other.


For level 5: report for the different test programs the CPI with and without pipelining.
How does it compare to the ideal CPI?
    I could not get the hazard detection to work. so could not get level 5 to work